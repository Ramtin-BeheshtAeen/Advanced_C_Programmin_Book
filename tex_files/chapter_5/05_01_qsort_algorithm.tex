\section{implementing simple qsort algorithm}

\begin{lstlisting}
 #include <stdio.h>
 #include <malloc.h>


 struct sorter {
         int n_item, start, end;
         int *data;
 };

 //The function is intended to create and return a pointer to a struct sorter
 struct sorter * sorter_create(int n){
         int *data;
         struct sorter *s = malloc(sizeof(struct sorter));

         if (s == NULL){
                 return NULL;
         }

         data = malloc(sizeof(int) * n);

         if (s->data == NULL){
                 free(s);
                 return NULL;
         }

         *s = (struct sorter){
                 .n_item = n,
                 .start  = 0,
                 .end    = 0,
                 .data   = data
         };

         return s;
 }

 void sorter_destroy(struct sorter *s){

 }


 /*
  * Adding values to data structure and simultaneously sorting them.
  */
 void sorter_add(struct sorter *s, int value){

 }

 int sorter_get(struct sorter *s){
         return 0;
 }




 void main(void){

         struct sorter *s;
         //it is going to sort 32 elements
         s = sorter_create(32);

         sorter_add(s, 3);
         sorter_add(s, 1);
         sorter_add(s, 2);

         for (int i = 0 ; i < 3; i++){
                 printf("%d \n", sorter_get(s));
         }



 }
\end{lstlisting}

Code Explanation:
\begin{enumerate}

        \item This function is intended to create and return a pointer to a struct sorter.
        The parameter n likely represents the number of items or the size of the data array.

        \item The sorter\_create function is intended to create and initialize a new struct sorter instance.
        Here is why such a function is useful:

        \begin{verbatim}
                struct sorter * sorter_create(int n){
                        ...
                }
        \end{verbatim}

        \begin{enumerate}
        \item \textbf{Encapsulation: } By using a function to create the structure, you encapsulate the creation logic. This makes the code cleaner and easier to maintain.
        \item \textbf{Initialization: } The function can initialize the structure\textquotesingle s members (like n\_item, start, end, and the data array)
         to appropriate values, ensuring the structure is in a valid state when it\textquotesingle s created.
        \item \textbf{Memory Allocation: } If the data array needs to be dynamically allocated based on the value of n, the function can handle this allocation. This is especially important for the flexible array member data[].
        \end{enumerate}

    
        


\end{enumerate}

when ever you are implemenitg anything in systeam first define the datastrature, why anything else will come after that..

